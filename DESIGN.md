# Design Documentation

## Components
* Interactive interface
* Sound synthesis

### Interactive Interface

We used HTML, CSS, and Flask to create an interactive web-based user interface for the platform. 

#### Design Decisions
* HTML inheritance(?): We extended all the webpages from `layout.html`, including another template, `inst.html`, from which the four instrument pages all extended. This reduced redundancy and made it easier to make formatting changes to many pages on the website at a time.
* Bootstrap Components: We used a lot of Bootstrap components and Bootstrap CSS classes in order to improve the website's aesthetics and organization. Components / classes used include:
    * Navbar (component)
    * display-1, display-2, lead (display fonts)
    * ml-2 (margins)
    * text-center, text-left (alignment)
    * Note; lot of redundancy to be removed probably
* 
* Writing to individual `.wav` files -- will make it easier to overlay stuff later
    * We could also delete one note at a time lol
* Each instrument on a separate webpage: felt like an intuitive way of ...
* Buttons for notes -- definitely a process to get here.

### Sound Synthesis

We used Python (using the library PortAudio through PyAudio) and Java (using the class StdAudio through Java's Sound API) to create all sounds heard in our app. 

#### Design Decisions
* We synthesized all melodic (sine, saw, and square) sounds in 'app.py', inside of 'def waveform'. There, we used the NumPy library to generate waveforms to later be interpreted as audio. While this was simpler, we could not synthesize drum sounds in Python due to the limitations of NumPy and PyAudio; we needed the capabilites of Java to be able to use a for loop to progressively adjust frequency levels of a sound over time, since only StdAudio could take an array generated by a for loop as input (ndarrays generated by NumPy were too limited). We created a simple program in Java, 'samples.java', to generate the four drum samples we used. We then (NEED TO RESOLVE FORMAT ISSUE).
* We mapped buttons to notes on the keyboard by using the algorithm in 'def playNote' to convert arbitrary numerical input into a specific frequency corresponding with the labelled note on the button pressed. This allowed for easy mapping that could be consistent across disparate sounds.
